"""
ReportGenerator - HTML Report Generation

Creates beautiful, interactive HTML reports from analyzed job matches.
"""

import os
import sys
import math
from datetime import datetime
from typing import List, Dict, Any, Optional
from pathlib import Path
import markdown2

# Add parent directory to path for profile_manager import
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.utils.profile_manager import ProfilePaths


class ReportGenerator:
    """Generate HTML reports from analyzed job matches"""

    def __init__(self, output_dir: Optional[str] = None, profile_name: Optional[str] = None):
        """
        Initialize ReportGenerator

        Args:
            output_dir: Directory to save reports (default: from profile)
            profile_name: Profile name (default: from .env ACTIVE_PROFILE)
        """
        # Get profile paths
        paths = ProfilePaths(profile_name)

        # Use profile reports directory as default, or custom dir if provided
        self.output_dir = output_dir or str(paths.reports_dir)
        Path(self.output_dir).mkdir(parents=True, exist_ok=True)

    def generate_report(
        self,
        jobs: List[Dict[str, Any]],
        report_title: str = "Job Match Report",
        filename: Optional[str] = None,
        source_file: Optional[str] = None,
        source: str = "indeed",
    ) -> str:
        """
        Generate HTML report from analyzed jobs

        Args:
            jobs: List of fully analyzed job dicts
            report_title: Title for the report
            filename: Optional filename (default: auto-generated with timestamp)
            source_file: Optional path to source JSON file (for metadata reference)
            source: Job source identifier (default: "indeed")

        Returns:
            Path to generated HTML file
        """
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"job_report_{source}_{timestamp}.html"

        output_path = os.path.join(self.output_dir, filename)

        # Store source for use in _generate_html
        self._current_source = source

        # Generate HTML
        html = self._generate_html(jobs, report_title, source_file)

        # Write to file
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(html)

        return output_path

    def _generate_html(self, jobs: List[Dict[str, Any]], report_title: str, source_file: Optional[str] = None) -> str:
        """Generate complete HTML document"""

        # Sort jobs by match score
        sorted_jobs = sorted(jobs, key=lambda x: x.get("match_score", 0), reverse=True)

        # Generate summary stats
        summary_html = self._generate_summary(sorted_jobs)

        # Generate job cards
        job_cards_html = "\n".join(
            [self._generate_job_card(job, i + 1) for i, job in enumerate(sorted_jobs)]
        )

        # Add source data metadata if provided
        source_meta = f'    <meta name="source-data" content="{source_file}">\n' if source_file else ''

        # Get source from the generate_report call (passed via self during generation)
        # Default to 'indeed' if not specified
        source_name = getattr(self, '_current_source', 'indeed')

        # Complete HTML document
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
{source_meta}    <title>{report_title}</title>
    <style>
        {self._get_css()}
    </style>
</head>
<body data-source="{source_name}">
    <div class="container">
        <header>
            <h1>{report_title}</h1>
            <p class="report-date">Generated: {datetime.now().strftime("%B %d, %Y at %I:%M %p")}</p>
        </header>

        {summary_html}

        <div class="jobs-container">
            <h2>Job Matches</h2>
            {job_cards_html}
        </div>

        <footer>
            <p>Generated by JobMatcher AI &copy; {datetime.now().year}</p>
        </footer>
    </div>

    <script>
        {self._get_javascript()}
    </script>
</body>
</html>"""

        return html

    def _generate_summary(self, jobs: List[Dict[str, Any]]) -> str:
        """Generate summary statistics section"""
        if not jobs:
            return "<div class='summary'>No jobs to display</div>"

        total_jobs = len(jobs)
        avg_score = sum(job.get("match_score", 0) for job in jobs) / total_jobs
        excellent_matches = sum(1 for job in jobs if job.get("match_score", 0) >= 90)
        good_matches = sum(
            1 for job in jobs if 80 <= job.get("match_score", 0) < 90
        )
        fair_matches = sum(
            1 for job in jobs if 70 <= job.get("match_score", 0) < 80
        )

        return f"""
        <div class="summary">
            <h2>Summary</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">{total_jobs}</div>
                    <div class="stat-label">Total Matches</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{avg_score:.1f}</div>
                    <div class="stat-label">Average Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{excellent_matches}</div>
                    <div class="stat-label">Excellent (90+)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{good_matches}</div>
                    <div class="stat-label">Good (80-89)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{fair_matches}</div>
                    <div class="stat-label">Fair (70-79)</div>
                </div>
            </div>
        </div>
        """

    def _generate_job_card(self, job: Dict[str, Any], index: int) -> str:
        """Generate HTML for a single job card"""
        title = job.get("title", "Unknown Position")
        company = job.get("company", "Unknown Company")
        location = job.get("location", "Unknown Location")
        job_url = job.get("job_url", "#")
        company_url = job.get("company_url", "")
        match_score = job.get("match_score", 0)
        remote = job.get("remote", False)
        job_type = job.get("job_type", "")
        date_posted = job.get("date_posted", "")

        # Format date posted
        date_display = self._format_date_posted(date_posted)

        # Salary info
        salary_html = self._format_salary(job)

        # Company name with optional link to company profile
        if company_url:
            company_html = f'<a href="{company_url}" target="_blank" class="company-link" title="View company profile">{company}</a>'
        else:
            company_html = f'<span class="company">{company}</span>'

        # Match score badge
        score_class = self._get_score_class(match_score)
        score_badge = f'<span class="score-badge {score_class}">{match_score}</span>'

        # Glassdoor-specific badges
        glassdoor_badges = []

        # Company rating badge
        if job.get("company_rating"):
            rating = job["company_rating"]
            glassdoor_badges.append(f'<span class="rating-badge" title="Glassdoor Company Rating">‚≠ê {rating:.1f}</span>')

        # Easy Apply badge
        if job.get("easy_apply"):
            glassdoor_badges.append('<span class="easy-apply-badge" title="Quick application process">‚úì Easy Apply</span>')

        # Occupation classification badge
        if job.get("occupation_code"):
            confidence = int((job.get("occupation_confidence", 0) * 100))
            occ_code = job["occupation_code"]
            glassdoor_badges.append(f'<span class="occupation-badge" title="{confidence}% classification confidence">{occ_code}</span>')

        # Salary source indicator
        if job.get("salary_source") == "ESTIMATED":
            glassdoor_badges.append('<span class="salary-source-badge" title="Salary estimated by Glassdoor">üí∞ Est. Salary</span>')

        # Sponsored badge
        if job.get("is_sponsored"):
            level = job.get("sponsorship_level", "Sponsored")
            glassdoor_badges.append(f'<span class="sponsored-badge" title="Promoted job posting">{level}</span>')

        glassdoor_badges_html = " ".join(glassdoor_badges) if glassdoor_badges else ""

        # Sections
        job_details_html = self._format_job_details(job)
        description_html = self._format_description(job)
        analysis_html = self._format_analysis(job)
        recommendations_html = self._format_recommendations(job)

        card_id = f"job-{index}"

        return f"""
        <div class="job-card" id="{card_id}">
            <div class="job-header">
                <div class="job-title-section">
                    <h3>{title}</h3>
                    <div class="job-meta">
                        {company_html}
                        <span class="separator">‚Ä¢</span>
                        <span class="location">{location}</span>
                        <span class="separator">‚Ä¢</span>
                        <span class="date-posted">Posted: {date_display}</span>
                        {f'<span class="separator">‚Ä¢</span><span class="remote-badge">Remote</span>' if remote else ''}
                        {f'<span class="separator">‚Ä¢</span><span class="job-type">{job_type}</span>' if job_type else ''}
                    </div>
                    {salary_html}
                    {f'<div class="glassdoor-badges">{glassdoor_badges_html}</div>' if glassdoor_badges_html else ''}
                </div>
                <div class="job-actions">
                    {score_badge}
                    <a href="{job_url}" target="_blank" class="apply-button">Apply Now</a>
                </div>
            </div>

            {job_details_html}
            {description_html}
            {analysis_html}
            {recommendations_html}
        </div>
        """

    def _format_salary(self, job: Dict[str, Any]) -> str:
        """Format salary information"""
        salary_min = job.get("salary_min")
        salary_max = job.get("salary_max")
        currency = job.get("salary_currency", "USD")
        period = job.get("salary_period", "yearly")

        # Defensive type conversion: handle string/int/float salary values
        try:
            if salary_min is not None:
                salary_min = float(salary_min)
                # Check for NaN
                if math.isnan(salary_min):
                    salary_min = None
            if salary_max is not None:
                salary_max = float(salary_max)
                # Check for NaN
                if math.isnan(salary_max):
                    salary_max = None
        except (TypeError, ValueError):
            # If conversion fails, skip salary display
            return ""

        # Display salary only if we have valid numeric values
        if salary_min and salary_max:
            return f'<div class="salary">${salary_min:,.0f} - ${salary_max:,.0f} {currency}/{period}</div>'
        elif salary_min:
            return f'<div class="salary">${salary_min:,.0f}+ {currency}/{period}</div>'
        else:
            return ""

    def _format_job_details(self, job: Dict[str, Any]) -> str:
        """Format enriched job details section"""
        # Extract enriched fields
        skills = job.get("skills", [])
        requirements = job.get("requirements", [])
        benefits = job.get("benefits", [])
        work_arrangements = job.get("work_arrangements", [])

        # Company enrichment fields
        company_size = job.get("company_size", "")
        company_description = job.get("company_description", "")
        company_website = job.get("company_website", "")
        company_revenue = job.get("company_revenue", "")
        company_industry = job.get("company_industry", "")

        # Glassdoor-specific fields
        company_rating = job.get("company_rating")
        company_full_name = job.get("company_full_name", "")
        company_division = job.get("company_division", "")
        occupation_code = job.get("occupation_code", "")
        occupation_confidence = job.get("occupation_confidence")
        salary_source = job.get("salary_source", "")
        easy_apply = job.get("easy_apply", False)
        is_sponsored = job.get("is_sponsored", False)

        # Advanced fields
        work_schedule = job.get("work_schedule", "")
        detailed_salary = job.get("detailed_salary", "")

        # Enhanced location
        location_city = job.get("location_city", "")
        location_state = job.get("location_state", "")
        location_country = job.get("location_country_name", "")

        # Build details HTML sections
        details_parts = []

        # Skills section
        if skills:
            skills_html = "".join([f"<span class='detail-tag'>{s}</span>" for s in skills])
            details_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Skills:</span>
                    <div class="detail-tags">{skills_html}</div>
                </div>
            """)

        # Requirements section
        if requirements:
            requirements_html = "".join([f"<span class='detail-tag'>{r}</span>" for r in requirements])
            details_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Requirements:</span>
                    <div class="detail-tags">{requirements_html}</div>
                </div>
            """)

        # Benefits section
        if benefits:
            benefits_html = "".join([f"<span class='detail-tag benefit-tag'>{b}</span>" for b in benefits])
            details_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Benefits:</span>
                    <div class="detail-tags">{benefits_html}</div>
                </div>
            """)

        # Work arrangements section
        if work_arrangements:
            arrangements_html = "".join([f"<span class='detail-tag'>{w}</span>" for w in work_arrangements])
            details_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Work Arrangements:</span>
                    <div class="detail-tags">{arrangements_html}</div>
                </div>
            """)

        # Work schedule
        if work_schedule:
            details_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Work Schedule:</span>
                    <span class="detail-value">{work_schedule}</span>
                </div>
            """)

        # Detailed salary info (if different from header)
        if detailed_salary:
            details_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Salary Details:</span>
                    <span class="detail-value">{detailed_salary}</span>
                </div>
            """)

        # Enhanced location
        if location_city or location_state or location_country:
            location_parts = [p for p in [location_city, location_state, location_country] if p]
            location_str = ", ".join(location_parts)
            details_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Location Details:</span>
                    <span class="detail-value">{location_str}</span>
                </div>
            """)

        # Glassdoor-specific information section
        glassdoor_parts = []

        if occupation_code:
            confidence_text = f" ({int(occupation_confidence * 100)}% confidence)" if occupation_confidence else ""
            glassdoor_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Job Classification:</span>
                    <span class="detail-value">{occupation_code}{confidence_text}</span>
                </div>
            """)

        if company_rating:
            glassdoor_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Company Rating:</span>
                    <span class="detail-value">‚≠ê {company_rating:.1f}/5.0 (Glassdoor)</span>
                </div>
            """)

        if company_full_name and company_full_name != job.get("company"):
            glassdoor_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Company Full Name:</span>
                    <span class="detail-value">{company_full_name}</span>
                </div>
            """)

        if company_division:
            glassdoor_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Division/Department:</span>
                    <span class="detail-value">{company_division}</span>
                </div>
            """)

        if salary_source:
            source_text = "Estimated by Glassdoor" if salary_source == "ESTIMATED" else "Provided by Employer"
            glassdoor_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Salary Data Source:</span>
                    <span class="detail-value">{source_text}</span>
                </div>
            """)

        if easy_apply:
            glassdoor_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Application Process:</span>
                    <span class="detail-value">‚úì Easy Apply (Quick application)</span>
                </div>
            """)

        if is_sponsored:
            sponsorship_level = job.get("sponsorship_level", "Sponsored")
            glassdoor_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Listing Type:</span>
                    <span class="detail-value">‚ö†Ô∏è {sponsorship_level} (Promoted posting)</span>
                </div>
            """)

        # Add Glassdoor section if we have any data
        if glassdoor_parts:
            details_parts.extend(glassdoor_parts)
            details_parts.append('<div class="detail-separator"></div>')

        # Company information section
        company_parts = []

        if company_size:
            company_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Company Size:</span>
                    <span class="detail-value">{company_size}</span>
                </div>
            """)

        if company_industry:
            company_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Industry:</span>
                    <span class="detail-value">{company_industry}</span>
                </div>
            """)

        if company_revenue:
            company_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Company Revenue:</span>
                    <span class="detail-value">{company_revenue}</span>
                </div>
            """)

        if company_website:
            company_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">Company Website:</span>
                    <span class="detail-value"><a href="{company_website}" target="_blank">{company_website}</a></span>
                </div>
            """)

        if company_description:
            company_parts.append(f"""
                <div class="detail-row">
                    <span class="detail-label">About Company:</span>
                    <div class="company-info">{company_description}</div>
                </div>
            """)

        # If we have any company info, add a separator
        if company_parts:
            details_parts.append('<div class="detail-separator"></div>')
            details_parts.extend(company_parts)

        # Only show section if we have any details
        if not details_parts:
            return ""

        details_html = "".join(details_parts)

        return f"""
        <details class="collapsible-section">
            <summary class="section-toggle">
                Job Details
            </summary>
            <div class="section-content">
                <div class="job-details-section">
                    {details_html}
                </div>
            </div>
        </details>
        """

    def _format_description(self, job: Dict[str, Any]) -> str:
        """Format job description section"""
        description = job.get("description", "No description available")

        # Handle None descriptions
        if description is None:
            description = "No description available"

        # Convert markdown to HTML
        description_html = markdown2.markdown(description, extras=["break-on-newline"])

        return f"""
        <details class="collapsible-section">
            <summary class="section-toggle">
                Job Description
            </summary>
            <div class="section-content">
                <div class="job-description">{description_html}</div>
            </div>
        </details>
        """

    def _format_analysis(self, job: Dict[str, Any]) -> str:
        """Format gap analysis section"""
        strengths = job.get("strengths", [])
        gaps = job.get("gaps", [])
        red_flags = job.get("red_flags", [])
        assessment = job.get("assessment", "")

        strengths_html = "".join([f"<li class='strength-item'>{s}</li>" for s in strengths])
        gaps_html = "".join([f"<li class='gap-item'>‚ö†Ô∏è {g}</li>" for g in gaps])
        red_flags_html = "".join([f"<li class='red-flag-item'>üö© {r}</li>" for r in red_flags]) if red_flags else ""

        return f"""
        <details class="collapsible-section">
            <summary class="section-toggle">
                Match Analysis
            </summary>
            <div class="section-content">
                <div class="analysis-section">
                    <h4>Strengths</h4>
                    <ul class="strengths-list">{strengths_html if strengths_html else '<li>No strengths identified</li>'}</ul>

                    <h4>Gaps</h4>
                    <ul class="gaps-list">{gaps_html if gaps_html else '<li>No gaps identified</li>'}</ul>

                    {f'<h4>Red Flags</h4><ul class="red-flags-list">{red_flags_html}</ul>' if red_flags_html else ''}

                    <h4>Assessment</h4>
                    <p class="assessment">{assessment}</p>
                </div>
            </div>
        </details>
        """

    def _format_recommendations(self, job: Dict[str, Any]) -> str:
        """Format resume recommendations section"""
        keywords = job.get("keywords", [])
        highlights = job.get("experience_highlights", [])
        sections = job.get("sections_to_expand", [])
        cover_letter = job.get("cover_letter_points", [])
        summary = job.get("resume_summary", "")

        keywords_html = "".join([f"<span class='keyword-tag'>{k}</span>" for k in keywords])
        highlights_html = "".join([f"<li>‚ú® {h}</li>" for h in highlights])
        sections_html = "".join([f"<li>üìù {s}</li>" for s in sections])
        cover_letter_html = "".join([f"<li>üí¨ {c}</li>" for c in cover_letter])

        return f"""
        <details class="collapsible-section">
            <summary class="section-toggle">
                Resume Recommendations
            </summary>
            <div class="section-content">
                <div class="recommendations-section">
                    {f'<h4>Suggested Resume Summary</h4><p class="resume-summary">{summary}</p>' if summary else ''}

                    <h4>Keywords to Include</h4>
                    <div class="keywords-container">{keywords_html if keywords_html else '<p>No keywords identified</p>'}</div>

                    <h4>Experience to Highlight</h4>
                    <ul class="highlights-list">{highlights_html if highlights_html else '<li>No highlights identified</li>'}</ul>

                    <h4>Sections to Expand</h4>
                    <ul class="sections-list">{sections_html if sections_html else '<li>No sections identified</li>'}</ul>

                    <h4>Cover Letter Talking Points</h4>
                    <ul class="cover-letter-list">{cover_letter_html if cover_letter_html else '<li>No talking points identified</li>'}</ul>
                </div>
            </div>
        </details>
        """

    def _format_text(self, text: str) -> str:
        """Format text with basic HTML paragraph breaks"""
        if not text:
            return ""
        # Convert newlines to <br> and preserve formatting
        return text.replace("\n\n", "</p><p>").replace("\n", "<br>")

    def _get_score_class(self, score: int) -> str:
        """Get CSS class for match score"""
        if score >= 90:
            return "score-excellent"
        elif score >= 80:
            return "score-good"
        elif score >= 70:
            return "score-fair"
        else:
            return "score-poor"

    def _format_date_posted(self, date_str: str) -> str:
        """Format date posted for display

        Args:
            date_str: Date string (YYYY-MM-DD format or empty)

        Returns:
            Formatted date string or "Unknown"
        """
        if not date_str:
            return "Unknown"

        try:
            # Try to parse and format nicely
            date_obj = datetime.strptime(date_str, "%Y-%m-%d")
            return date_obj.strftime("%B %d, %Y")  # e.g., "October 11, 2025"
        except (ValueError, TypeError):
            # If parsing fails, return as-is or Unknown
            return date_str if date_str else "Unknown"

    def _get_css(self) -> str:
        """Get CSS styles for the report"""
        try:
            css_path = Path(__file__).parent / "report_style.css"
            if not css_path.exists():
                print(f"‚ö†Ô∏è  CSS file not found: {css_path}")
                return ""  # Return empty string instead of None
            return css_path.read_text(encoding="utf-8")
        except Exception as e:
            print(f"‚ö†Ô∏è  Error reading CSS file: {e}")
            return ""  # Return empty string on error

    def _get_javascript(self) -> str:
        """Get JavaScript for interactive features"""
        return """
        // Report uses native <details>/<summary> elements - no JavaScript needed!
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Job Match Report loaded successfully');
        });
        """


if __name__ == "__main__":
    # Test the report generator
    print("Testing ReportGenerator...")

    # Sample jobs data
    sample_jobs = [
        {
            "title": "Senior Payroll Manager",
            "company": "Tech Corp",
            "location": "Remote",
            "job_url": "https://example.com/job1",
            "remote": True,
            "job_type": "full-time",
            "salary_min": 90000,
            "salary_max": 120000,
            "salary_currency": "USD",
            "salary_period": "yearly",
            "description": "We are seeking an experienced Senior Payroll Manager...",
            "match_score": 85,
            "strengths": [
                "5+ years payroll experience",
                "Strong Excel skills",
                "Multi-state compliance knowledge",
            ],
            "gaps": ["Limited Workday experience"],
            "red_flags": [],
            "assessment": "Strong candidate with relevant experience",
            "keywords": ["ADP", "Workday", "Multi-state", "Compliance"],
            "experience_highlights": ["Managed payroll for 500+ employees"],
            "sections_to_expand": ["Technical Skills: Add Workday details"],
            "cover_letter_points": ["Highlight payroll systems experience"],
            "resume_summary": "Experienced payroll professional with 7+ years...",
        },
    ]

    generator = ReportGenerator()
    output_path = generator.generate_report(sample_jobs, "Test Report")

    print(f"Report generated: {output_path}")
    print("\nOpen the report in your browser to view!")
